# æ§åˆ¶ç»„ - ç¬¬äºŒå‘¨ä»»åŠ¡æ¸…å•

## ä»»åŠ¡æ¦‚è§ˆ

**ç›®æ ‡**ï¼šå®ŒæˆCANæ¡¥æ¥èŠ‚ç‚¹å®ç°ï¼ŒéªŒè¯ROS2åˆ°æœºå™¨äººçš„å®Œæ•´æ§åˆ¶é“¾è·¯ï¼Œå®ç°å•è½´å’ŒåŒè½´åè°ƒè¿åŠ¨

**å…³é”®æˆæœ**ï¼š
1. CANæ¡¥æ¥èŠ‚ç‚¹å¯é è¿è¡Œ
2. å®ç°ä½ç½®/é€Ÿåº¦æ§åˆ¶æ¨¡å¼
3. å®Œæˆå•è½´ç²¾åº¦æµ‹è¯•
4. åŒè½´åè°ƒè¿åŠ¨éªŒè¯
5. åŸºç¡€å®‰å…¨ç›‘æ§åŠŸèƒ½

**å‰ç½®æ¡ä»¶**ï¼š
- âœ… ROS2ç¯å¢ƒå·²é…ç½®
- âœ… è½¨è¿¹æ’­æ”¾å™¨å·²å®ç°
- âœ… è‡ªå®šä¹‰æ¶ˆæ¯å·²å®šä¹‰
- âœ… è™šæ‹ŸCANæµ‹è¯•é€šè¿‡

---

## Day 1ï¼ˆå‘¨ä¸€ï¼‰ï¼šCANæ¡¥æ¥èŠ‚ç‚¹å®Œå–„

### ä¸Šåˆï¼šå®é™…CANç¡¬ä»¶è¿æ¥

```bash
# 1. æ£€æŸ¥CANç¡¬ä»¶ï¼ˆPCAN-USBæˆ–å…¶ä»–ï¼‰
lsusb | grep -i peak  # ä»¥PCANä¸ºä¾‹

# 2. åŠ è½½CANé©±åŠ¨
sudo modprobe peak_usb
sudo ip link set can0 type can bitrate 1000000
sudo ip link set up can0

# 3. éªŒè¯CANè¿æ¥
candump can0  # åº”èƒ½çœ‹åˆ°ç”µæœºå¿ƒè·³æŠ¥æ–‡
```

### ä¸‹åˆï¼šè®¾è®¡å¯æ‰©å±•CANåè®®æ¶æ„

**èƒŒæ™¯**ï¼šæ”¯æŒä¸¤ç§åè®®æ¨¡å¼
1. ç›´æ¥å¯¹ç”µæœºé©±åŠ¨å™¨ï¼ˆæ ‡å‡†CANopenåè®®ï¼‰
2. å¯¹ç°æœ‰æœºå™¨ä¸‹ä½æœºï¼ˆè‡ªå®šä¹‰CANåè®®ï¼‰

åˆ›å»º `include/can_protocol_interface.h` åè®®æŠ½è±¡æ¥å£ï¼š

```cpp
#ifndef CAN_PROTOCOL_INTERFACE_H
#define CAN_PROTOCOL_INTERFACE_H

#include <cstdint>
#include <string>
#include <memory>

namespace surgical_robot {

// ç”µæœºçŠ¶æ€ç»“æ„
struct MotorStatus {
    int32_t actual_position;    // å®é™…ä½ç½® (counts)
    int32_t actual_velocity;    // å®é™…é€Ÿåº¦ (counts/s)
    int16_t actual_torque;      // å®é™…åŠ›çŸ©
    uint16_t status_word;       // çŠ¶æ€å­—
    uint16_t error_code;        // é”™è¯¯ä»£ç 
    bool is_enabled;            // æ˜¯å¦ä½¿èƒ½
    bool has_fault;             // æ˜¯å¦æ•…éšœ
};

// è¿åŠ¨å‘½ä»¤ç»“æ„
struct MotionCommand {
    int32_t target_position;    // ç›®æ ‡ä½ç½® (counts)
    int32_t target_velocity;    // ç›®æ ‡é€Ÿåº¦ (counts/s)
    uint8_t control_mode;       // æ§åˆ¶æ¨¡å¼ï¼š1=ä½ç½®, 3=é€Ÿåº¦
};

// CANåè®®æŠ½è±¡æ¥å£
class CANProtocolInterface {
public:
    virtual ~CANProtocolInterface() = default;
    
    // åè®®åˆå§‹åŒ–
    virtual bool initialize(const std::string& can_interface) = 0;
    
    // ç”µæœºç®¡ç†
    virtual bool enableMotor(uint8_t motor_id) = 0;
    virtual bool disableMotor(uint8_t motor_id) = 0;
    virtual bool resetMotor(uint8_t motor_id) = 0;
    virtual bool emergencyStop(uint8_t motor_id) = 0;
    
    // è¿åŠ¨æ§åˆ¶
    virtual bool sendPositionCommand(uint8_t motor_id, const MotionCommand& cmd) = 0;
    virtual bool sendVelocityCommand(uint8_t motor_id, const MotionCommand& cmd) = 0;
    
    // çŠ¶æ€è¯»å–
    virtual bool readMotorStatus(uint8_t motor_id, MotorStatus& status) = 0;
    
    // åè®®ä¿¡æ¯
    virtual std::string getProtocolName() const = 0;
    virtual std::string getVersion() const = 0;
    
protected:
    std::string can_interface_;
    int can_fd_ = -1;
};

// åè®®å·¥å‚
class CANProtocolFactory {
public:
    enum class ProtocolType {
        CANOPEN,        // æ ‡å‡†CANopenåè®®
        CUSTOM_V1       // è‡ªå®šä¹‰åè®®v1ï¼ˆå¾…å®ç°ï¼‰
    };
    
    static std::unique_ptr<CANProtocolInterface> create(ProtocolType type);
    static std::vector<std::string> getAvailableProtocols();
};

} // namespace surgical_robot

#endif // CAN_PROTOCOL_INTERFACE_H
```

åˆ›å»º `include/canopen_protocol.h` CANopenåè®®å®ç°ï¼š

```cpp
#ifndef CANOPEN_PROTOCOL_H
#define CANOPEN_PROTOCOL_H

#include "can_protocol_interface.h"
#include <map>
#include <mutex>

namespace surgical_robot {

// CANopen åŠŸèƒ½ç 
constexpr uint16_t NMT_COMMAND = 0x000;
constexpr uint16_t TPDO1_BASE = 0x180;
constexpr uint16_t RPDO1_BASE = 0x200;
constexpr uint16_t TPDO2_BASE = 0x280;
constexpr uint16_t RPDO2_BASE = 0x300;
constexpr uint16_t SDO_TX_BASE = 0x580;
constexpr uint16_t SDO_RX_BASE = 0x600;
constexpr uint16_t HEARTBEAT_BASE = 0x700;

// æ§åˆ¶å­—å®šä¹‰ï¼ˆDS402ï¼‰
constexpr uint16_t CONTROLWORD_SHUTDOWN = 0x0006;
constexpr uint16_t CONTROLWORD_SWITCH_ON = 0x0007;
constexpr uint16_t CONTROLWORD_ENABLE_OP = 0x000F;
constexpr uint16_t CONTROLWORD_QUICK_STOP = 0x0002;
constexpr uint16_t CONTROLWORD_RESET_FAULT = 0x0080;

// CANopenåè®®å®ç°
class CANopenProtocol : public CANProtocolInterface {
public:
    CANopenProtocol();
    ~CANopenProtocol() override;
    
    // ç»§æ‰¿æ¥å£å®ç°
    bool initialize(const std::string& can_interface) override;
    bool enableMotor(uint8_t motor_id) override;
    bool disableMotor(uint8_t motor_id) override;
    bool resetMotor(uint8_t motor_id) override;
    bool emergencyStop(uint8_t motor_id) override;
    bool sendPositionCommand(uint8_t motor_id, const MotionCommand& cmd) override;
    bool sendVelocityCommand(uint8_t motor_id, const MotionCommand& cmd) override;
    bool readMotorStatus(uint8_t motor_id, MotorStatus& status) override;
    std::string getProtocolName() const override { return "CANopen DS402"; }
    std::string getVersion() const override { return "1.0.0"; }

private:
    // CANopenç‰¹æœ‰æ–¹æ³•
    bool sendSDO(uint8_t node_id, uint16_t index, uint8_t subindex, 
                 const void* data, uint8_t size);
    bool sendControlword(uint8_t node_id, uint16_t controlword);
    bool sendNMT(uint8_t node_id, uint8_t command);
    
    std::map<uint8_t, MotorStatus> motor_states_;
    std::mutex state_mutex_;
};

} // namespace surgical_robot

#endif // CANOPEN_PROTOCOL_H
```

### éªŒæ”¶æ ‡å‡†

- [ ] å®é™…CANè®¾å¤‡è¯†åˆ«æˆåŠŸ
- [ ] èƒ½æ¥æ”¶ç”µæœºå¿ƒè·³æŠ¥æ–‡
- [ ] PDOç»“æ„å®šä¹‰å®Œæ•´

---

## Day 2ï¼ˆå‘¨äºŒï¼‰ï¼šåŸºäºåè®®æ¥å£çš„CANæ¡¥æ¥èŠ‚ç‚¹å®ç°

### ä¸Šåˆï¼šåè®®å·¥å‚å’ŒCANopenå®ç°

åˆ›å»º `src/canopen_protocol.cpp` CANopenåè®®å…·ä½“å®ç°ï¼š

```cpp
#include "canopen_protocol.h"
#include <sys/socket.h>
#include <linux/can.h>
#include <linux/can/raw.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <cstring>

namespace surgical_robot {

CANopenProtocol::CANopenProtocol() = default;

CANopenProtocol::~CANopenProtocol() {
    if (can_fd_ >= 0) {
        close(can_fd_);
    }
}

bool CANopenProtocol::initialize(const std::string& can_interface) {
    can_interface_ = can_interface;
    
    // åˆ›å»ºCAN socket
    can_fd_ = socket(PF_CAN, SOCK_RAW, CAN_RAW);
    if (can_fd_ < 0) return false;
    
    // ç»‘å®šæ¥å£
    struct ifreq ifr;
    strcpy(ifr.ifr_name, can_interface.c_str());
    ioctl(can_fd_, SIOCGIFINDEX, &ifr);
    
    struct sockaddr_can addr;
    addr.can_family = AF_CAN;
    addr.can_ifindex = ifr.ifr_ifindex;
    
    return bind(can_fd_, (struct sockaddr *)&addr, sizeof(addr)) >= 0;
}

bool CANopenProtocol::enableMotor(uint8_t motor_id) {
    // CANopen DS402çŠ¶æ€æœºåºåˆ—
    if (!sendControlword(motor_id, CONTROLWORD_SHUTDOWN)) return false;
    std::this_thread::sleep_for(std::chrono::milliseconds(50));
    
    if (!sendControlword(motor_id, CONTROLWORD_SWITCH_ON)) return false;
    std::this_thread::sleep_for(std::chrono::milliseconds(50));
    
    if (!sendControlword(motor_id, CONTROLWORD_ENABLE_OP)) return false;
    
    return true;
}

bool CANopenProtocol::sendPositionCommand(uint8_t motor_id, const MotionCommand& cmd) {
    struct can_frame frame;
    frame.can_id = RPDO1_BASE + motor_id;
    frame.can_dlc = 8;
    
    // å¡«å……RPDO1æ•°æ®ï¼ˆæ§åˆ¶å­— + ç›®æ ‡ä½ç½®ï¼‰
    uint16_t controlword = 0x001F; // ä½ç½®æ¨¡å¼æ§åˆ¶å­—
    memcpy(&frame.data[0], &controlword, 2);
    memcpy(&frame.data[2], &cmd.target_position, 4);
    frame.data[6] = 0;
    frame.data[7] = 0;
    
    return write(can_fd_, &frame, sizeof(frame)) == sizeof(frame);
}

// ... å…¶ä»–æ–¹æ³•å®ç° ...

} // namespace surgical_robot
```

åˆ›å»º `src/protocol_factory.cpp` åè®®å·¥å‚å®ç°ï¼š

```cpp
#include "can_protocol_interface.h"
#include "canopen_protocol.h"

namespace surgical_robot {

std::unique_ptr<CANProtocolInterface> CANProtocolFactory::create(ProtocolType type) {
    switch (type) {
        case ProtocolType::CANOPEN:
            return std::make_unique<CANopenProtocol>();
        case ProtocolType::CUSTOM_V1:
            // TODO: å®ç°è‡ªå®šä¹‰åè®®
            return nullptr;
        default:
            return nullptr;
    }
}

std::vector<std::string> CANProtocolFactory::getAvailableProtocols() {
    return {"CANopen", "Custom_V1"};
}

} // namespace surgical_robot
```

### ä¸‹åˆï¼šä½¿ç”¨åè®®æ¥å£çš„CANæ¡¥æ¥èŠ‚ç‚¹

æ›´æ–° `can_bridge_node.cpp` ä½¿ç”¨æ–°çš„åè®®æ¶æ„ï¼š

```cpp
#include <rclcpp/rclcpp.hpp>
#include <thread>
#include <mutex>
#include "surgical_robot_control/msg/trajectory_point.hpp"
#include "surgical_robot_control/msg/robot_state.hpp"
#include "can_protocol_interface.h"

class CANBridgeNode : public rclcpp::Node {
public:
    CANBridgeNode() : Node("can_bridge_node") {
        // å‚æ•°å£°æ˜
        this->declare_parameter<std::string>("protocol_type", "CANopen");
        this->declare_parameter<std::string>("can_interface", "can0");
        this->declare_parameter<int>("push_motor_id", 1);
        this->declare_parameter<int>("rotate_motor_id", 2);
        this->declare_parameter<double>("push_ratio", 1000.0);
        this->declare_parameter<double>("rotate_ratio", 100.0);
        
        // è·å–å‚æ•°
        std::string protocol_str = this->get_parameter("protocol_type").as_string();
        can_interface_ = this->get_parameter("can_interface").as_string();
        push_motor_id_ = this->get_parameter("push_motor_id").as_int();
        rotate_motor_id_ = this->get_parameter("rotate_motor_id").as_int();
        push_ratio_ = this->get_parameter("push_ratio").as_double();
        rotate_ratio_ = this->get_parameter("rotate_ratio").as_double();
        
        // åˆ›å»ºåè®®å®ä¾‹
        CANProtocolFactory::ProtocolType protocol_type;
        if (protocol_str == "CANopen") {
            protocol_type = CANProtocolFactory::ProtocolType::CANOPEN;
        } else if (protocol_str == "Custom_V1") {
            protocol_type = CANProtocolFactory::ProtocolType::CUSTOM_V1;
        } else {
            RCLCPP_ERROR(this->get_logger(), "ä¸æ”¯æŒçš„åè®®ç±»å‹: %s", protocol_str.c_str());
            return;
        }
        
        protocol_ = CANProtocolFactory::create(protocol_type);
        if (!protocol_) {
            RCLCPP_ERROR(this->get_logger(), "åˆ›å»ºåè®®å®ä¾‹å¤±è´¥");
            return;
        }
        
        // åˆå§‹åŒ–åè®®
        if (!protocol_->initialize(can_interface_)) {
            RCLCPP_ERROR(this->get_logger(), "åè®®åˆå§‹åŒ–å¤±è´¥");
            return;
        }
        
        RCLCPP_INFO(this->get_logger(), "ä½¿ç”¨åè®®: %s v%s", 
                    protocol_->getProtocolName().c_str(),
                    protocol_->getVersion().c_str());
        
        // åˆ›å»ºROS2æ¥å£
        setupROS2Interface();
        
        // åˆå§‹åŒ–ç”µæœº
        initMotors();
    }
    
private:
    void setupROS2Interface() {
        // è®¢é˜…è½¨è¿¹å‘½ä»¤
        trajectory_sub_ = this->create_subscription<surgical_robot_control::msg::TrajectoryPoint>(
            "trajectory_command", 10,
            std::bind(&CANBridgeNode::trajectoryCallback, this, std::placeholders::_1));
            
        // å‘å¸ƒæœºå™¨äººçŠ¶æ€
        state_pub_ = this->create_publisher<surgical_robot_control::msg::RobotState>(
            "robot_state", 10);
            
        // çŠ¶æ€å‘å¸ƒå®šæ—¶å™¨ï¼ˆ50Hzï¼‰
        state_timer_ = this->create_wall_timer(
            std::chrono::milliseconds(20),
            std::bind(&CANBridgeNode::publishState, this));
    }
    
    void trajectoryCallback(const surgical_robot_control::msg::TrajectoryPoint::SharedPtr msg) {
        // å•ä½è½¬æ¢
        MotionCommand push_cmd;
        push_cmd.target_position = static_cast<int32_t>(msg->push_position * push_ratio_);
        push_cmd.target_velocity = static_cast<int32_t>(msg->push_velocity * push_ratio_);
        push_cmd.control_mode = 1; // ä½ç½®æ¨¡å¼
        
        MotionCommand rotate_cmd;
        rotate_cmd.target_position = static_cast<int32_t>(msg->rotate_angle * rotate_ratio_);
        rotate_cmd.target_velocity = static_cast<int32_t>(msg->angular_velocity * rotate_ratio_);
        rotate_cmd.control_mode = 1; // ä½ç½®æ¨¡å¼
        
        // å‘é€å‘½ä»¤ï¼ˆç»Ÿä¸€æ¥å£ï¼Œä¸ä¾èµ–å…·ä½“åè®®ï¼‰
        protocol_->sendPositionCommand(push_motor_id_, push_cmd);
        protocol_->sendPositionCommand(rotate_motor_id_, rotate_cmd);
        
        RCLCPP_DEBUG(this->get_logger(), "å‘é€ä½ç½®å‘½ä»¤: push=%d, rotate=%d", 
                     push_cmd.target_position, rotate_cmd.target_position);
    }
    
    void initMotors() {
        // ä½¿ç”¨ç»Ÿä¸€æ¥å£åˆå§‹åŒ–ç”µæœº
        if (protocol_->enableMotor(push_motor_id_)) {
            RCLCPP_INFO(this->get_logger(), "æ¨é€ç”µæœºä½¿èƒ½æˆåŠŸ");
        } else {
            RCLCPP_ERROR(this->get_logger(), "æ¨é€ç”µæœºä½¿èƒ½å¤±è´¥");
        }
        
        if (protocol_->enableMotor(rotate_motor_id_)) {
            RCLCPP_INFO(this->get_logger(), "æ—‹è½¬ç”µæœºä½¿èƒ½æˆåŠŸ");
        } else {
            RCLCPP_ERROR(this->get_logger(), "æ—‹è½¬ç”µæœºä½¿èƒ½å¤±è´¥");
        }
    }
    
    void publishState() {
        auto state_msg = surgical_robot_control::msg::RobotState();
        state_msg.timestamp = this->now().seconds();
        
        // è¯»å–æ¨é€ç”µæœºçŠ¶æ€
        MotorStatus push_status;
        if (protocol_->readMotorStatus(push_motor_id_, push_status)) {
            state_msg.actual_push_position = push_status.actual_position / push_ratio_;
            state_msg.push_force = push_status.actual_torque * 0.01; // è½¬æ¢ä¸ºN
        }
        
        // è¯»å–æ—‹è½¬ç”µæœºçŠ¶æ€
        MotorStatus rotate_status;
        if (protocol_->readMotorStatus(rotate_motor_id_, rotate_status)) {
            state_msg.actual_rotate_angle = rotate_status.actual_position / rotate_ratio_;
            state_msg.rotate_torque = rotate_status.actual_torque * 0.001; // è½¬æ¢ä¸ºNm
        }
        
        // çŠ¶æ€åˆ¤æ–­
        if (push_status.has_fault || rotate_status.has_fault) {
            state_msg.status = 2; // é”™è¯¯
            state_msg.error_message = "ç”µæœºæ•…éšœ";
        } else if (push_status.is_enabled && rotate_status.is_enabled) {
            state_msg.status = 1; // è¿åŠ¨ä¸­
        } else {
            state_msg.status = 0; // ç©ºé—²
        }
        
        state_pub_->publish(state_msg);
    }
    
    std::unique_ptr<CANProtocolInterface> protocol_;
    std::string can_interface_;
    uint8_t push_motor_id_;
    uint8_t rotate_motor_id_;
    double push_ratio_;
    double rotate_ratio_;
    
    rclcpp::Subscription<surgical_robot_control::msg::TrajectoryPoint>::SharedPtr trajectory_sub_;
    rclcpp::Publisher<surgical_robot_control::msg::RobotState>::SharedPtr state_pub_;
    rclcpp::TimerBase::SharedPtr state_timer_;
};

int main(int argc, char * argv[]) {
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<CANBridgeNode>());
    rclcpp::shutdown();
    return 0;
}
```

### ä¸‹åˆï¼šé”™è¯¯å¤„ç†å’Œæ¢å¤

æ·»åŠ å¼‚å¸¸å¤„ç†æœºåˆ¶ï¼š

```cpp
void handleMotorFault(uint8_t node_id) {
    RCLCPP_WARN(this->get_logger(), "ç”µæœº%dæ•…éšœï¼Œå°è¯•æ¢å¤", node_id);
    
    // è¯»å–é”™è¯¯ä»£ç 
    uint16_t error_code = readErrorCode(node_id);
    RCLCPP_ERROR(this->get_logger(), "é”™è¯¯ä»£ç : 0x%04X", error_code);
    
    // å°è¯•å¤ä½
    sendControlword(node_id, CONTROLWORD_RESET_FAULT);
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    
    // é‡æ–°ä½¿èƒ½
    enableMotor(node_id);
}

void emergencyStop() {
    RCLCPP_ERROR(this->get_logger(), "ç´§æ€¥åœæ­¢ï¼");
    sendControlword(push_motor_id_, CONTROLWORD_QUICK_STOP);
    sendControlword(rotate_motor_id_, CONTROLWORD_QUICK_STOP);
}
```

### åè®®é…ç½®ç¤ºä¾‹

åˆ›å»º `config/canopen_config.yaml`ï¼š

```yaml
can_bridge_node:
  ros__parameters:
    protocol_type: "CANopen"        # æˆ– "Custom_V1"
    can_interface: "can0"
    push_motor_id: 1
    rotate_motor_id: 2
    push_ratio: 1000.0              # counts/mm
    rotate_ratio: 100.0             # counts/degree
```

å¯åŠ¨å‘½ä»¤ï¼š

```bash
# ä½¿ç”¨CANopenåè®®
ros2 run surgical_robot_control can_bridge_node \
    --ros-args --params-file config/canopen_config.yaml

# ä½¿ç”¨è‡ªå®šä¹‰åè®®ï¼ˆæœªæ¥å®ç°ï¼‰
ros2 run surgical_robot_control can_bridge_node \
    --ros-args -p protocol_type:="Custom_V1"
```

### éªŒæ”¶æ ‡å‡†

- [ ] åè®®æ¥å£æŠ½è±¡è®¾è®¡å®Œæˆ
- [ ] CANopenåè®®å®ç°å¯ç”¨
- [ ] åè®®å·¥å‚æ¨¡å¼è¿è¡Œæ­£å¸¸
- [ ] å¯é€šè¿‡å‚æ•°åˆ‡æ¢åè®®ç±»å‹
- [ ] ä¸ºè‡ªå®šä¹‰åè®®é¢„ç•™æ¥å£

---

## Day 3ï¼ˆå‘¨ä¸‰ï¼‰ï¼šå•è½´è¿åŠ¨æµ‹è¯•

### ä¸Šåˆï¼šä½ç½®æ§åˆ¶ç²¾åº¦æµ‹è¯•

åˆ›å»º `test/single_axis_test.cpp`ï¼š

```cpp
#include <rclcpp/rclcpp.hpp>
#include <vector>
#include <fstream>
#include "surgical_robot_control/msg/trajectory_point.hpp"
#include "surgical_robot_control/msg/robot_state.hpp"

class SingleAxisTest : public rclcpp::Node {
public:
    SingleAxisTest() : Node("single_axis_test") {
        // å‘å¸ƒæµ‹è¯•è½¨è¿¹
        cmd_pub_ = this->create_publisher<surgical_robot_control::msg::TrajectoryPoint>(
            "trajectory_command", 10);
            
        // è®¢é˜…çŠ¶æ€åé¦ˆ
        state_sub_ = this->create_subscription<surgical_robot_control::msg::RobotState>(
            "robot_state", 10,
            std::bind(&SingleAxisTest::stateCallback, this, std::placeholders::_1));
            
        // æµ‹è¯•å®šæ—¶å™¨
        test_timer_ = this->create_wall_timer(
            std::chrono::seconds(2),
            std::bind(&SingleAxisTest::runTest, this));
    }
    
private:
    void runTest() {
        static int test_index = 0;
        static std::vector<double> test_positions = {0, 10, 20, 30, 20, 10, 0}; // mm
        
        if (test_index >= test_positions.size()) {
            // æµ‹è¯•å®Œæˆï¼Œç”ŸæˆæŠ¥å‘Š
            generateReport();
            rclcpp::shutdown();
            return;
        }
        
        // å‘é€ä½ç½®å‘½ä»¤
        auto msg = surgical_robot_control::msg::TrajectoryPoint();
        msg.timestamp = this->now().seconds();
        msg.push_position = test_positions[test_index];
        msg.rotate_angle = 0.0;
        msg.push_velocity = 5.0; // mm/s
        msg.angular_velocity = 0.0;
        
        cmd_pub_->publish(msg);
        target_position_ = test_positions[test_index];
        
        RCLCPP_INFO(this->get_logger(), "å‘é€ç›®æ ‡ä½ç½®: %.2f mm", target_position_);
        test_index++;
    }
    
    void stateCallback(const surgical_robot_control::msg::RobotState::SharedPtr msg) {
        // è®°å½•å®é™…ä½ç½®
        position_data_.push_back({
            msg->timestamp,
            target_position_,
            msg->actual_push_position,
            msg->actual_push_position - target_position_
        });
    }
    
    void generateReport() {
        std::ofstream report("single_axis_test_report.csv");
        report << "timestamp,target_mm,actual_mm,error_mm\n";
        
        double max_error = 0.0;
        double sum_error = 0.0;
        
        for (const auto& data : position_data_) {
            report << data.timestamp << ","
                   << data.target << ","
                   << data.actual << ","
                   << data.error << "\n";
                   
            max_error = std::max(max_error, std::abs(data.error));
            sum_error += std::abs(data.error);
        }
        
        double avg_error = sum_error / position_data_.size();
        
        RCLCPP_INFO(this->get_logger(), "æµ‹è¯•å®Œæˆ:");
        RCLCPP_INFO(this->get_logger(), "  å¹³å‡è¯¯å·®: %.3f mm", avg_error);
        RCLCPP_INFO(this->get_logger(), "  æœ€å¤§è¯¯å·®: %.3f mm", max_error);
        RCLCPP_INFO(this->get_logger(), "  æµ‹è¯•ç»“æœ: %s", 
                    max_error < 0.5 ? "é€šè¿‡" : "å¤±è´¥");
    }
    
    struct PositionData {
        double timestamp;
        double target;
        double actual;
        double error;
    };
    
    std::vector<PositionData> position_data_;
    double target_position_ = 0.0;
    
    rclcpp::Publisher<surgical_robot_control::msg::TrajectoryPoint>::SharedPtr cmd_pub_;
    rclcpp::Subscription<surgical_robot_control::msg::RobotState>::SharedPtr state_sub_;
    rclcpp::TimerBase::SharedPtr test_timer_;
};
```

### ä¸‹åˆï¼šé€Ÿåº¦æ§åˆ¶ç¨³å®šæ€§æµ‹è¯•

åˆ›å»ºé€Ÿåº¦é˜¶è·ƒå“åº”æµ‹è¯•ï¼ŒéªŒè¯é€Ÿåº¦æ§åˆ¶æ€§èƒ½ã€‚

### éªŒæ”¶æ ‡å‡†

- [ ] ä½ç½®æ§åˆ¶ç²¾åº¦ < 0.5mm
- [ ] é€Ÿåº¦è·Ÿè¸ªç¨³å®š
- [ ] æµ‹è¯•æŠ¥å‘Šè‡ªåŠ¨ç”Ÿæˆ

---

## Day 4ï¼ˆå‘¨å››ï¼‰ï¼šåŒè½´åè°ƒè¿åŠ¨

### ä¸Šåˆï¼šåŒæ­¥è¿åŠ¨æ§åˆ¶

åˆ›å»º `dual_axis_controller.cpp`ï¼š

```cpp
class DualAxisController : public rclcpp::Node {
public:
    DualAxisController() : Node("dual_axis_controller") {
        // è½¨è¿¹è®¢é˜…
        trajectory_sub_ = this->create_subscription<surgical_robot_control::msg::TrajectoryPoint>(
            "trajectory_command", 10,
            std::bind(&DualAxisController::trajectoryCallback, this, std::placeholders::_1));
            
        // åŒæ­¥æ§åˆ¶å®šæ—¶å™¨ï¼ˆ100Hzï¼‰
        control_timer_ = this->create_wall_timer(
            std::chrono::milliseconds(10),
            std::bind(&DualAxisController::controlLoop, this));
    }
    
private:
    void trajectoryCallback(const surgical_robot_control::msg::TrajectoryPoint::SharedPtr msg) {
        // è¿åŠ¨å­¦è§£ç®—
        double push_distance = msg->push_position - current_push_position_;
        double rotate_angle = msg->rotate_angle - current_rotate_angle_;
        
        // æ—¶é—´åŒæ­¥è®¡ç®—
        double push_time = std::abs(push_distance) / msg->push_velocity;
        double rotate_time = std::abs(rotate_angle) / msg->angular_velocity;
        double sync_time = std::max(push_time, rotate_time);
        
        // è°ƒæ•´é€Ÿåº¦ä»¥åŒæ­¥å®Œæˆ
        if (sync_time > 0) {
            synchronized_push_velocity_ = push_distance / sync_time;
            synchronized_rotate_velocity_ = rotate_angle / sync_time;
        }
        
        target_push_position_ = msg->push_position;
        target_rotate_angle_ = msg->rotate_angle;
        motion_start_time_ = this->now();
    }
    
    void controlLoop() {
        if (!isMotionActive()) return;
        
        auto elapsed = (this->now() - motion_start_time_).seconds();
        
        // æ¢¯å½¢é€Ÿåº¦è§„åˆ’
        double push_cmd = trapezoidalProfile(
            current_push_position_, target_push_position_,
            synchronized_push_velocity_, elapsed);
            
        double rotate_cmd = trapezoidalProfile(
            current_rotate_angle_, target_rotate_angle_,
            synchronized_rotate_velocity_, elapsed);
            
        // å‘é€åŒæ­¥å‘½ä»¤
        sendSynchronizedCommand(push_cmd, rotate_cmd);
    }
    
    // ... å…¶ä»–å®ç° ...
};
```

### ä¸‹åˆï¼šèºæ—‹è¿åŠ¨æµ‹è¯•

åˆ›å»ºèºæ—‹è½¨è¿¹æµ‹è¯•æ–‡ä»¶ `test_helix.csv`ï¼š

```csv
time_ms,push_mm,rotate_deg,velocity_mm_s,angular_velocity_deg_s
0,0.0,0.0,2.0,36.0
100,0.2,3.6,2.0,36.0
200,0.4,7.2,2.0,36.0
300,0.6,10.8,2.0,36.0
...
```

### éªŒæ”¶æ ‡å‡†

- [ ] åŒè½´è¿åŠ¨æ—¶é—´åŒæ­¥ < 10ms
- [ ] èºæ—‹è½¨è¿¹è·Ÿè¸ªè¯¯å·® < 1mm
- [ ] æ— æ˜æ˜¾æŠ–åŠ¨æˆ–æŒ¯è¡

---

## Day 5ï¼ˆå‘¨äº”ï¼‰ï¼šå®‰å…¨ç›‘æ§å®ç°

### ä¸Šåˆï¼šè½¯ä»¶é™ä½å’Œé€Ÿåº¦é™åˆ¶

åˆ›å»º `safety_monitor.cpp`ï¼š

```cpp
#include <rclcpp/rclcpp.hpp>
#include "surgical_robot_control/msg/robot_state.hpp"
#include "surgical_robot_control/msg/trajectory_point.hpp"

class SafetyMonitor : public rclcpp::Node {
public:
    SafetyMonitor() : Node("safety_monitor") {
        // åŠ è½½å®‰å…¨å‚æ•°
        this->declare_parameter<double>("max_push_position", 300.0); // mm
        this->declare_parameter<double>("min_push_position", 0.0);
        this->declare_parameter<double>("max_rotate_angle", 720.0); // åº¦
        this->declare_parameter<double>("max_push_velocity", 10.0); // mm/s
        this->declare_parameter<double>("max_angular_velocity", 180.0); // åº¦/s
        this->declare_parameter<double>("max_push_force", 5.0); // N
        this->declare_parameter<double>("max_rotate_torque", 0.1); // Nm
        
        loadSafetyLimits();
        
        // è®¢é˜…
        state_sub_ = this->create_subscription<surgical_robot_control::msg::RobotState>(
            "robot_state", 10,
            std::bind(&SafetyMonitor::stateCallback, this, std::placeholders::_1));
            
        cmd_sub_ = this->create_subscription<surgical_robot_control::msg::TrajectoryPoint>(
            "trajectory_command_raw", 10,
            std::bind(&SafetyMonitor::commandCallback, this, std::placeholders::_1));
            
        // å‘å¸ƒ
        safe_cmd_pub_ = this->create_publisher<surgical_robot_control::msg::TrajectoryPoint>(
            "trajectory_command", 10);
            
        emergency_stop_pub_ = this->create_publisher<std_msgs::msg::Bool>(
            "emergency_stop", 10);
            
        // ç›‘æ§å®šæ—¶å™¨ï¼ˆ50Hzï¼‰
        monitor_timer_ = this->create_wall_timer(
            std::chrono::milliseconds(20),
            std::bind(&SafetyMonitor::monitorSafety, this));
    }
    
private:
    void commandCallback(const surgical_robot_control::msg::TrajectoryPoint::SharedPtr msg) {
        auto safe_msg = *msg;
        
        // ä½ç½®é™åˆ¶
        safe_msg.push_position = std::clamp(
            msg->push_position, 
            limits_.min_push_position, 
            limits_.max_push_position);
            
        safe_msg.rotate_angle = std::clamp(
            msg->rotate_angle,
            -limits_.max_rotate_angle,
            limits_.max_rotate_angle);
            
        // é€Ÿåº¦é™åˆ¶
        safe_msg.push_velocity = std::min(
            msg->push_velocity,
            limits_.max_push_velocity);
            
        safe_msg.angular_velocity = std::min(
            msg->angular_velocity,
            limits_.max_angular_velocity);
            
        // å‘å¸ƒå®‰å…¨å‘½ä»¤
        safe_cmd_pub_->publish(safe_msg);
        
        if (safe_msg.push_position != msg->push_position ||
            safe_msg.push_velocity != msg->push_velocity) {
            RCLCPP_WARN(this->get_logger(), "å‘½ä»¤è¢«å®‰å…¨é™åˆ¶ä¿®æ”¹");
        }
    }
    
    void stateCallback(const surgical_robot_control::msg::RobotState::SharedPtr msg) {
        std::lock_guard<std::mutex> lock(state_mutex_);
        current_state_ = *msg;
        
        // åŠ›/åŠ›çŸ©ç›‘æ§
        if (std::abs(msg->push_force) > limits_.max_push_force) {
            RCLCPP_ERROR(this->get_logger(), 
                "æ¨é€åŠ›è¶…é™: %.2f N (é™åˆ¶: %.2f N)", 
                msg->push_force, limits_.max_push_force);
            triggerEmergencyStop();
        }
        
        if (std::abs(msg->rotate_torque) > limits_.max_rotate_torque) {
            RCLCPP_ERROR(this->get_logger(), 
                "æ—‹è½¬åŠ›çŸ©è¶…é™: %.3f Nm (é™åˆ¶: %.3f Nm)", 
                msg->rotate_torque, limits_.max_rotate_torque);
            triggerEmergencyStop();
        }
    }
    
    void monitorSafety() {
        std::lock_guard<std::mutex> lock(state_mutex_);
        
        // æ£€æŸ¥é€šä¿¡è¶…æ—¶
        auto time_since_update = (this->now() - 
            rclcpp::Time(current_state_.timestamp)).seconds();
            
        if (time_since_update > 0.5) {  // 500msè¶…æ—¶
            RCLCPP_ERROR(this->get_logger(), "çŠ¶æ€æ›´æ–°è¶…æ—¶");
            triggerEmergencyStop();
        }
        
        // æ£€æŸ¥é”™è¯¯çŠ¶æ€
        if (current_state_.status == 2) {  // é”™è¯¯çŠ¶æ€
            RCLCPP_ERROR(this->get_logger(), 
                "æœºå™¨äººé”™è¯¯: %s", current_state_.error_message.c_str());
            triggerEmergencyStop();
        }
    }
    
    void triggerEmergencyStop() {
        auto msg = std_msgs::msg::Bool();
        msg.data = true;
        emergency_stop_pub_->publish(msg);
        
        RCLCPP_ERROR(this->get_logger(), "è§¦å‘ç´§æ€¥åœæ­¢!");
    }
    
    struct SafetyLimits {
        double max_push_position;
        double min_push_position;
        double max_rotate_angle;
        double max_push_velocity;
        double max_angular_velocity;
        double max_push_force;
        double max_rotate_torque;
    } limits_;
    
    surgical_robot_control::msg::RobotState current_state_;
    std::mutex state_mutex_;
    
    // ... å…¶ä»–æˆå‘˜ ...
};
```

### ä¸‹åˆï¼šé›†æˆæµ‹è¯•å’Œæ–‡æ¡£

1. å®Œæ•´ç³»ç»Ÿæµ‹è¯•
2. æ€§èƒ½æŒ‡æ ‡æµ‹é‡
3. æ“ä½œæ‰‹å†Œç¼–å†™

### éªŒæ”¶æ ‡å‡†

- [ ] è½¯é™ä½åŠŸèƒ½æ­£å¸¸
- [ ] åŠ›çŸ©ä¿æŠ¤è§¦å‘å¯é 
- [ ] ç´§æ€¥åœæ­¢å“åº” < 50ms

---

## å‘¨æœ«ä»»åŠ¡ï¼šç³»ç»Ÿé›†æˆä¸æ¼”ç¤ºå‡†å¤‡

### ä»»åŠ¡1ï¼šåˆ›å»ºå®Œæ•´å¯åŠ¨æ–‡ä»¶

`launch/full_system.launch.py`ï¼š

```python
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription
from launch.substitutions import LaunchConfiguration
from launch.launch_description_sources import PythonLaunchDescriptionSource
import os

def generate_launch_description():
    # å‚æ•°å£°æ˜
    can_interface = DeclareLaunchArgument(
        'can_interface',
        default_value='can0',
        description='CAN interface name'
    )
    
    trajectory_file = DeclareLaunchArgument(
        'trajectory_file',
        default_value='',
        description='Trajectory CSV file (optional)'
    )
    
    # CANæ¡¥æ¥èŠ‚ç‚¹
    can_bridge_node = Node(
        package='surgical_robot_control',
        executable='can_bridge_node',
        name='can_bridge',
        parameters=[{
            'can_interface': LaunchConfiguration('can_interface'),
            'push_motor_id': 1,
            'rotate_motor_id': 2,
            'push_ratio': 1000.0,
            'rotate_ratio': 100.0
        }],
        output='screen'
    )
    
    # åŒè½´æ§åˆ¶å™¨
    dual_axis_controller = Node(
        package='surgical_robot_control',
        executable='dual_axis_controller',
        name='dual_axis_controller',
        output='screen'
    )
    
    # å®‰å…¨ç›‘æ§
    safety_monitor = Node(
        package='surgical_robot_control',
        executable='safety_monitor',
        name='safety_monitor',
        parameters=[{
            'max_push_position': 300.0,
            'max_push_velocity': 10.0,
            'max_push_force': 5.0
        }],
        output='screen'
    )
    
    # æ¡ä»¶æ€§åŒ…å«è½¨è¿¹æ’­æ”¾å™¨
    trajectory_player = Node(
        package='surgical_robot_control',
        executable='trajectory_player',
        name='trajectory_player',
        parameters=[{
            'trajectory_file': LaunchConfiguration('trajectory_file')
        }],
        condition=IfCondition(LaunchConfiguration('trajectory_file')),
        output='screen'
    )
    
    return LaunchDescription([
        can_interface,
        trajectory_file,
        can_bridge_node,
        dual_axis_controller,
        safety_monitor,
        trajectory_player
    ])
```

### ä»»åŠ¡2ï¼šæ€§èƒ½æµ‹è¯•è„šæœ¬

åˆ›å»º `scripts/performance_test.py`ï¼š

```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
import numpy as np
import matplotlib.pyplot as plt
from surgical_robot_control.msg import TrajectoryPoint, RobotState
import time

class PerformanceTest(Node):
    def __init__(self):
        super().__init__('performance_test')
        
        # å‘å¸ƒå™¨å’Œè®¢é˜…å™¨
        self.cmd_pub = self.create_publisher(
            TrajectoryPoint, 'trajectory_command', 10)
        self.state_sub = self.create_subscription(
            RobotState, 'robot_state', self.state_callback, 10)
            
        # æ•°æ®è®°å½•
        self.cmd_timestamps = []
        self.state_timestamps = []
        self.latencies = []
        
        # æµ‹è¯•å®šæ—¶å™¨
        self.create_timer(0.02, self.send_test_command)  # 50Hz
        
    def send_test_command(self):
        msg = TrajectoryPoint()
        msg.timestamp = self.get_clock().now().to_msg().sec
        msg.push_position = 10.0 * np.sin(time.time())
        msg.rotate_angle = 30.0 * np.cos(time.time())
        msg.push_velocity = 5.0
        msg.angular_velocity = 60.0
        
        self.cmd_pub.publish(msg)
        self.cmd_timestamps.append(time.time())
        
    def state_callback(self, msg):
        self.state_timestamps.append(time.time())
        
        # è®¡ç®—å»¶è¿Ÿ
        if len(self.cmd_timestamps) > 0:
            latency = (time.time() - self.cmd_timestamps[-1]) * 1000  # ms
            self.latencies.append(latency)
            
    def generate_report(self):
        if len(self.latencies) > 0:
            avg_latency = np.mean(self.latencies)
            max_latency = np.max(self.latencies)
            min_latency = np.min(self.latencies)
            
            print(f"æ€§èƒ½æµ‹è¯•ç»“æœ:")
            print(f"  å¹³å‡å»¶è¿Ÿ: {avg_latency:.2f} ms")
            print(f"  æœ€å¤§å»¶è¿Ÿ: {max_latency:.2f} ms")
            print(f"  æœ€å°å»¶è¿Ÿ: {min_latency:.2f} ms")
            
            # ç»˜åˆ¶å»¶è¿Ÿåˆ†å¸ƒå›¾
            plt.figure(figsize=(10, 6))
            plt.hist(self.latencies, bins=50)
            plt.xlabel('å»¶è¿Ÿ (ms)')
            plt.ylabel('é¢‘æ¬¡')
            plt.title('æ§åˆ¶å»¶è¿Ÿåˆ†å¸ƒ')
            plt.savefig('latency_distribution.png')
            plt.close()

def main():
    rclpy.init()
    node = PerformanceTest()
    
    try:
        # è¿è¡Œ30ç§’æµ‹è¯•
        start_time = time.time()
        while time.time() - start_time < 30:
            rclpy.spin_once(node, timeout_sec=0.01)
            
    except KeyboardInterrupt:
        pass
        
    finally:
        node.generate_report()
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### ä»»åŠ¡3ï¼šè‡ªå®šä¹‰åè®®æ¨¡æ¿å‡†å¤‡

ä¸ºæœªæ¥çš„è‡ªå®šä¹‰åè®®åˆ›å»ºæ¨¡æ¿ `include/custom_protocol_template.h`ï¼š

```cpp
#ifndef CUSTOM_PROTOCOL_TEMPLATE_H
#define CUSTOM_PROTOCOL_TEMPLATE_H

#include "can_protocol_interface.h"

namespace surgical_robot {

// è‡ªå®šä¹‰åè®®æ¨¡æ¿ï¼ˆæ ¹æ®å®é™…ä¸‹ä½æœºåè®®è°ƒæ•´ï¼‰
class CustomProtocol : public CANProtocolInterface {
public:
    CustomProtocol();
    ~CustomProtocol() override;
    
    // å®ç°æŠ½è±¡æ¥å£
    bool initialize(const std::string& can_interface) override;
    bool enableMotor(uint8_t motor_id) override;
    bool disableMotor(uint8_t motor_id) override;
    bool resetMotor(uint8_t motor_id) override;
    bool emergencyStop(uint8_t motor_id) override;
    bool sendPositionCommand(uint8_t motor_id, const MotionCommand& cmd) override;
    bool sendVelocityCommand(uint8_t motor_id, const MotionCommand& cmd) override;
    bool readMotorStatus(uint8_t motor_id, MotorStatus& status) override;
    std::string getProtocolName() const override { return "Custom Protocol V1"; }
    std::string getVersion() const override { return "1.0.0"; }

private:
    // è‡ªå®šä¹‰åè®®çš„CAN IDå®šä¹‰
    static constexpr uint32_t CMD_POSITION_BASE = 0x100;     // ä½ç½®å‘½ä»¤åŸºç¡€ID
    static constexpr uint32_t CMD_VELOCITY_BASE = 0x200;     // é€Ÿåº¦å‘½ä»¤åŸºç¡€ID
    static constexpr uint32_t STATUS_FEEDBACK_BASE = 0x300;  // çŠ¶æ€åé¦ˆåŸºç¡€ID
    static constexpr uint32_t EMERGENCY_STOP_ID = 0x000;     // æ€¥åœå‘½ä»¤ID
    
    // è‡ªå®šä¹‰åè®®çš„æ•°æ®ç»“æ„
    struct CustomPositionCmd {
        uint8_t motor_id;
        int32_t target_position;
        uint16_t velocity;
        uint8_t reserved;
    } __attribute__((packed));
    
    struct CustomStatusFeedback {
        uint8_t motor_id;
        int32_t actual_position;
        int16_t actual_velocity;
        uint8_t status_flags;
    } __attribute__((packed));
    
    // åè®®ç‰¹æœ‰æ–¹æ³•
    bool sendCustomCommand(uint32_t can_id, const void* data, uint8_t length);
    bool receiveCustomStatus(uint32_t can_id, void* data, uint8_t& length);
    
    // çŠ¶æ€ç¼“å­˜
    std::map<uint8_t, MotorStatus> motor_states_;
    std::mutex state_mutex_;
};

} // namespace surgical_robot

#endif // CUSTOM_PROTOCOL_TEMPLATE_H
```

### è‡ªå®šä¹‰åè®®é›†æˆè¯´æ˜

å½“è·å¾—å®é™…ä¸‹ä½æœºåè®®åï¼Œéœ€è¦ï¼š

1. **ä¿®æ”¹åè®®IDå’Œæ•°æ®ç»“æ„**ï¼š
   ```cpp
   // æ ¹æ®å®é™…åè®®æ–‡æ¡£ä¿®æ”¹
   static constexpr uint32_t CMD_POSITION_BASE = 0xå®é™…ID;
   ```

2. **å®ç°å…·ä½“çš„å‘é€/æ¥æ”¶é€»è¾‘**ï¼š
   ```cpp
   bool CustomProtocol::sendPositionCommand(uint8_t motor_id, const MotionCommand& cmd) {
       // æŒ‰ç…§å®é™…åè®®æ ¼å¼å°è£…æ•°æ®
       CustomPositionCmd custom_cmd;
       custom_cmd.motor_id = motor_id;
       custom_cmd.target_position = cmd.target_position;
       // ... å…¶ä»–å­—æ®µæ˜ å°„
       
       return sendCustomCommand(CMD_POSITION_BASE + motor_id, &custom_cmd, sizeof(custom_cmd));
   }
   ```

3. **æ›´æ–°åè®®å·¥å‚**ï¼š
   ```cpp
   case ProtocolType::CUSTOM_V1:
       return std::make_unique<CustomProtocol>();
   ```

### ä»»åŠ¡4ï¼šç¬¬äºŒå‘¨è¿›åº¦æŠ¥å‘Š

åˆ›å»º `week2_report.md`ï¼š

```markdown
# æ§åˆ¶ç»„ç¬¬äºŒå‘¨è¿›åº¦æŠ¥å‘Š

## å®Œæˆæƒ…å†µ

### 1. å¯æ‰©å±•åè®®æ¶æ„
- [x] åè®®æŠ½è±¡æ¥å£è®¾è®¡
- [x] CANopenåè®®å®ç°
- [x] åè®®å·¥å‚æ¨¡å¼
- [x] è‡ªå®šä¹‰åè®®æ¨¡æ¿å‡†å¤‡

### 2. CANé€šä¿¡å®ç°
- [x] å®é™…ç¡¬ä»¶è¿æ¥é…ç½®
- [x] çŠ¶æ€æœºç®¡ç†
- [x] å‚æ•°åŒ–é…ç½®æ”¯æŒ

### 3. è¿åŠ¨æ§åˆ¶
- [x] å•è½´ä½ç½®æ§åˆ¶ï¼ˆç²¾åº¦<0.5mmï¼‰
- [x] åŒè½´åŒæ­¥æ§åˆ¶
- [x] é€Ÿåº¦è§„åˆ’ç®—æ³•
- [x] è½¨è¿¹è·Ÿè¸ªæµ‹è¯•

### 4. å®‰å…¨åŠŸèƒ½
- [x] è½¯ä»¶é™ä½ä¿æŠ¤
- [x] åŠ›/åŠ›çŸ©ç›‘æ§
- [x] ç´§æ€¥åœæ­¢æœºåˆ¶
- [x] é”™è¯¯æ¢å¤æµç¨‹

### 5. ç³»ç»Ÿé›†æˆ
- [x] å®Œæ•´å¯åŠ¨æ–‡ä»¶
- [x] æ€§èƒ½æµ‹è¯•å·¥å…·
- [x] æ“ä½œæ–‡æ¡£

## æ¶æ„ä¼˜åŠ¿

- **åè®®æ— å…³æ€§**ï¼šä¸Šå±‚ROS2èŠ‚ç‚¹ä¸ä¾èµ–å…·ä½“CANåè®®
- **æ˜“äºæ‰©å±•**ï¼šæ–°åè®®åªéœ€å®ç°æ¥å£ï¼Œæ— éœ€ä¿®æ”¹ä¸»è¦é€»è¾‘
- **é…ç½®çµæ´»**ï¼šé€šè¿‡å‚æ•°è½»æ¾åˆ‡æ¢åè®®æ¨¡å¼
- **ä»£ç å¤ç”¨**ï¼šå®‰å…¨ç›‘æ§ã€å•ä½è½¬æ¢ç­‰é€»è¾‘é€šç”¨

## å…³é”®æŒ‡æ ‡

| æŒ‡æ ‡ | ç›®æ ‡å€¼ | å®æµ‹å€¼ | çŠ¶æ€ |
|------|--------|--------|------|
| ä½ç½®ç²¾åº¦ | <0.5mm | 0.3mm | âœ… |
| æ§åˆ¶å»¶è¿Ÿ | <100ms | 45ms | âœ… |
| åŒæ­¥è¯¯å·® | <10ms | 5ms | âœ… |
| æ€¥åœå“åº” | <50ms | 30ms | âœ… |
| åè®®åˆ‡æ¢ | æ— ç¼ | é…ç½®åˆ‡æ¢ | âœ… |

## é—®é¢˜ä¸è§£å†³

1. **åè®®æŠ½è±¡å±‚æ€§èƒ½**
   - æ‹…å¿ƒï¼šè™šå‡½æ•°è°ƒç”¨å¼€é”€
   - éªŒè¯ï¼šå®æµ‹å»¶è¿Ÿå¢åŠ <1msï¼Œå¯æ¥å—

2. **å†…å­˜ç®¡ç†**
   - é—®é¢˜ï¼šæ™ºèƒ½æŒ‡é’ˆä½¿ç”¨
   - è§£å†³ï¼šä½¿ç”¨unique_ptrï¼Œé¿å…å†…å­˜æ³„æ¼

## æ¼”ç¤ºè§†é¢‘

- CANopenåè®®æ§åˆ¶ï¼š[video_link]
- åè®®åˆ‡æ¢æ¼”ç¤ºï¼š[video_link]
- åŒè½´èºæ—‹è¿åŠ¨ï¼š[video_link]
- å®‰å…¨åŠŸèƒ½æ¼”ç¤ºï¼š[video_link]

## å¾…å®ç°åŠŸèƒ½

- [ ] è‡ªå®šä¹‰åè®®å…·ä½“å®ç°ï¼ˆéœ€è¦å®é™…åè®®æ–‡æ¡£ï¼‰
- [ ] åè®®æ€§èƒ½å¯¹æ¯”æµ‹è¯•
- [ ] åè®®è‡ªåŠ¨æ£€æµ‹åŠŸèƒ½

## ä¸‹å‘¨è®¡åˆ’

å¼€å§‹Phase 2ï¼šè¡€ç®¡åˆ†å‰²å¿«é€ŸåŸå‹
- å‡†å¤‡DSAå›¾åƒæ•°æ®é›†
- æ­å»ºæ·±åº¦å­¦ä¹ ç¯å¢ƒ
- è®­ç»ƒåˆç‰ˆåˆ†å‰²æ¨¡å‹
```

### éªŒæ”¶æ ‡å‡†

- [ ] å®Œæ•´ç³»ç»Ÿå¯ä¸€é”®å¯åŠ¨
- [ ] æ€§èƒ½æŒ‡æ ‡è¾¾æ ‡
- [ ] æœ‰æ¼”ç¤ºè§†é¢‘è®°å½•

---

## æ¯æ—¥æ£€æŸ¥æ¸…å•

### ç¯å¢ƒæ£€æŸ¥è„šæœ¬æ›´æ–°

```bash
#!/bin/bash
# check_week2_env.sh

echo "=== æ§åˆ¶ç»„ç¬¬äºŒå‘¨ç¯å¢ƒæ£€æŸ¥ ==="

# åŸºç¡€æ£€æŸ¥
echo -n "ROS2ç¯å¢ƒ: "
if command -v ros2 &> /dev/null; then
    echo "âœ“"
else
    echo "âœ—"
fi

# CANè®¾å¤‡æ£€æŸ¥
echo -n "CANæ¥å£: "
if ip link show can0 &> /dev/null 2>&1; then
    echo "âœ“ can0å·²é…ç½®"
else
    echo "âœ— can0æœªæ‰¾åˆ°"
fi

# èŠ‚ç‚¹ç¼–è¯‘æ£€æŸ¥
echo -n "CANæ¡¥æ¥èŠ‚ç‚¹: "
if [ -f "$HOME/surgical_robot_ws/install/surgical_robot_control/lib/surgical_robot_control/can_bridge_node" ]; then
    echo "âœ“ å·²ç¼–è¯‘"
else
    echo "âœ— æœªç¼–è¯‘"
fi

# ç”µæœºé€šä¿¡æ£€æŸ¥
echo -n "ç”µæœºå¿ƒè·³: "
timeout 2 candump can0 2>/dev/null | grep -q "7[0-9][0-9]"
if [ $? -eq 0 ]; then
    echo "âœ“ æ£€æµ‹åˆ°å¿ƒè·³"
else
    echo "âœ— æ— å¿ƒè·³ä¿¡å·"
fi
```

---

## æŠ€æœ¯è¦ç‚¹æé†’

### CANé€šä¿¡è°ƒè¯•æŠ€å·§

```bash
# ç›‘æ§æ‰€æœ‰CANæ¶ˆæ¯
candump -ta can0

# å‘é€SDOè¯»å–çŠ¶æ€å­—
cansend can0 601#4041600000000000

# å‘é€ä½ç½®å‘½ä»¤ï¼ˆRPDO1ï¼‰
cansend can0 201#0F00E803000000000  # æ§åˆ¶å­—0x000Fï¼Œä½ç½®1000

# æŸ¥çœ‹CANç»Ÿè®¡
ip -s link show can0
```

### ROS2è°ƒè¯•å‘½ä»¤

```bash
# æŸ¥çœ‹æ‰€æœ‰è¯é¢˜
ros2 topic list

# ç›‘æ§æœºå™¨äººçŠ¶æ€
ros2 topic echo /robot_state

# å‘é€æµ‹è¯•å‘½ä»¤
ros2 topic pub /trajectory_command surgical_robot_control/msg/TrajectoryPoint \
  "{push_position: 10.0, rotate_angle: 30.0, push_velocity: 5.0, angular_velocity: 60.0}"

# æŸ¥çœ‹èŠ‚ç‚¹å…³ç³»å›¾
ros2 run rqt_graph rqt_graph
```

---

**ç¬¬äºŒå‘¨ç›®æ ‡è¾¾æˆæ ‡å‡†**ï¼š

1. èƒ½å¤Ÿé€šè¿‡ROS2æ§åˆ¶å®é™…ç”µæœºè¿åŠ¨
2. åŒè½´åè°ƒè¿åŠ¨æµç•…æ— æŠ–åŠ¨
3. å®‰å…¨ä¿æŠ¤æœºåˆ¶å¯é è§¦å‘
4. ç³»ç»Ÿé›†æˆæµ‹è¯•å…¨éƒ¨é€šè¿‡

ğŸ’¡ **å…³é”®é‡Œç¨‹ç¢‘**ï¼šå®Œæˆä»"è½¨è¿¹æ–‡ä»¶â†’ROS2â†’CANâ†’ç”µæœºè¿åŠ¨"çš„å®Œæ•´æ§åˆ¶é“¾è·¯éªŒè¯ï¼ 